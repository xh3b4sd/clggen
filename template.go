package main

// Templates represents the templates of the source code files being generated.
var Templates = map[string]string{
	"generated.go":        generatedGo,
	"generated_common.go": generatedCommonGo,
	"generated_error.go":  generatedErrorGo,
	"generated_object.go": generatedObjectGo,
}

var generatedGo = `package {{.PackageName}}

	// This file is generated by the CLG generator. Don't edit it manually. The CLG
	// generator is invoked by go generate. For more information about the usage of
	// the CLG generator check https://github.com/xh3b4sd/clggen or have a look at
	// the network package. There is the go generate statement to invoke clggen.

	import (
		"reflect"

		"github.com/xh3b4sd/anna/api"
		"github.com/xh3b4sd/anna/factory/id"
		"github.com/xh3b4sd/anna/log"
		"github.com/xh3b4sd/anna/spec"
		"github.com/xh3b4sd/anna/storage/memory"
	)

	const (
		// ObjectType represents the object type of the CLG object. This is used
		// e.g. to register itself to the logger.
		ObjectType spec.ObjectType = "clg"
	)

	// Config represents the configuration used to create a new CLG object.
	type Config struct {
		// Dependencies.
		Log     spec.Log
		Storage spec.Storage

		// Settings.
		InputChannel chan spec.NetworkPayload
	}

	// DefaultConfig provides a default configuration to create a new CLG object by
	// best effort.
	func DefaultConfig() Config {
		newStorage, err := memory.NewStorage(memory.DefaultStorageConfig())
		if err != nil {
			panic(err)
		}

		newConfig := Config{
			// Dependencies.
			Log:     log.NewLog(log.DefaultConfig()),
			Storage: newStorage,

			// Settings.
			InputChannel: make(chan spec.NetworkPayload, 1000),
		}

		return newConfig
	}

	// New creates a new configured CLG object.
	func New(config Config) (spec.CLG, error) {
		newCLG := &clg{
			Config: config,
			ID:     id.MustNew(),
			Type:   ObjectType,
		}

		// Dependencies.
		if newCLG.Log == nil {
			return nil, maskAnyf(invalidConfigError, "logger must not be empty")
		}
		if newCLG.Storage == nil {
			return nil, maskAnyf(invalidConfigError, "storage must not be empty")
		}

		// Settings.
		if newCLG.InputChannel == nil {
			return nil, maskAnyf(invalidConfigError, "input channel must not be empty")
		}

		newCLG.Log.Register(newCLG.GetType())

		return newCLG, nil
	}

	// MustNew creates either a new default configured CLG object, or panics.
	func MustNew() spec.CLG {
		newCLG, err := New(DefaultConfig())
		if err != nil {
			panic(err)
		}

		return newCLG
	}

	type clg struct {
		Config

		ID   spec.ObjectID
		Type spec.ObjectType
	}

	func (c *clg) Calculate(payload spec.NetworkPayload) (spec.NetworkPayload, error) {
		outputs, err := filterError(reflect.ValueOf(c.calculate).Call(payload.GetArgs()))
		if err != nil {
			return nil, maskAny(err)
		}

		newNetworkPayloadConfig := api.DefaultNetworkPayloadConfig()
		newNetworkPayloadConfig.Args = outputs
		newNetworkPayloadConfig.Destination = "must be set by spec.Network.Forward"
		newNetworkPayloadConfig.Sources = []spec.ObjectID{payload.GetDestination()}
		newNetworkPayload, err := api.NewNetworkPayload(newNetworkPayloadConfig)
		if err != nil {
			return nil, maskAny(err)
		}

		return newNetworkPayload, nil
	}

	func (c *clg) GetName() string {
		return "{{.CLGName}}"
	}

	func (c *clg) GetInputChannel() chan spec.NetworkPayload {
		return c.InputChannel
	}

	func (c *clg) GetInputTypes() []reflect.Type {
		t := reflect.TypeOf(c.calculate)

		var inputType []reflect.Type

		for i := 0; i < t.NumIn(); i++ {
			inputType = append(inputType, t.In(i))
		}

		return inputType
	}

	func (c *clg) SetLog(log spec.Log) {
		c.Log = log
	}

	func (c *clg) SetStorage(storage spec.Storage) {
		c.Storage = storage
	}
`

var generatedCommonGo = `package {{.PackageName}}

	// This file is generated by the CLG generator. Don't edit it manually. The CLG
	// generator is invoked by go generate. For more information about the usage of
	// the CLG generator check https://github.com/xh3b4sd/clggen or have a look at
	// the network package. There is the go generate statement to invoke clggen.

	import (
		"reflect"
	)

	// filterError expects the given list of reflect values to be the output of a
	// CLG execution. In case a CLG returns an error, the error must be the last
	// element of the output, otherwise filterError will throw an error, because of
	// the invalid CLG interface. All elements of values, except the error, if any,
	// will not be included in the returned argument list.
	func filterError(values []reflect.Value) ([]reflect.Value, error) {
		if len(values) == 0 {
			return nil, nil
		}

		var outputs []reflect.Value

		for i, v := range values {
			if err, ok := v.Interface().(error); ok {
				if i != len(values)-1 {
					// In golang we expect the error to be the last element of the output.
					// If this is not the case, we throw an error.
					return nil, maskAnyf(invalidInterfaceError, "error must be last")
				}
				if err != nil {
					// There was an error in the CLG output.
					return nil, maskAny(err)
				}
			}

			outputs = append(outputs, v)
		}

		return outputs, nil
	}
`

var generatedErrorGo = `package {{.PackageName}}

	// This file is generated by the CLG generator. Don't edit it manually. The CLG
	// generator is invoked by go generate. For more information about the usage of
	// the CLG generator check https://github.com/xh3b4sd/clggen or have a look at
	// the network package. There is the go generate statement to invoke clggen.

	import (
		"fmt"

		"github.com/juju/errgo"
	)

	var (
		maskAny = errgo.MaskFunc(errgo.Any)
	)

	func maskAnyf(err error, f string, v ...interface{}) error {
		if err == nil {
			return nil
		}

		f = fmt.Sprintf("%s: %s", err.Error(), f)
		newErr := errgo.WithCausef(nil, errgo.Cause(err), f, v...)
		newErr.(*errgo.Err).SetLocation(1)

		return newErr
	}

	var invalidConfigError = errgo.New("invalid config")

	// IsInvalidConfig asserts invalidConfigError.
	func IsInvalidConfig(err error) bool {
		return errgo.Cause(err) == invalidConfigError
	}

	var invalidInterfaceError = errgo.New("invalid interface")

	// IsInvalidInterface asserts invalidInterfaceError.
	func IsInvalidInterface(err error) bool {
		return errgo.Cause(err) == invalidInterfaceError
	}
`

var generatedObjectGo = `package {{.PackageName}}

	// This file is generated by the CLG generator. Don't edit it manually. The CLG
	// generator is invoked by go generate. For more information about the usage of
	// the CLG generator check https://github.com/xh3b4sd/clggen or have a look at
	// the network package. There is the go generate statement to invoke clggen.

	import (
		"github.com/xh3b4sd/anna/spec"
	)

	func (c *clg) GetID() spec.ObjectID {
		return c.ID
	}

	func (c *clg) GetType() spec.ObjectType {
		return c.Type
	}
`
